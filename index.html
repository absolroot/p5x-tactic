<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>페르소나5X 택틱</title>
  <link rel="icon" type="image/x-icon" href="./img/ui/favicon.ico">
  <link rel="stylesheet" href="./styles.css">

  <!-- Google Analytics 추적 코드 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SJ93CPWQPE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-SJ93CPWQPE'); // 여기에 본인의 추적 ID(G-XXXXXXX) 입력
  </script>

  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
    <!-- 데이터 파일들 -->
    <script src="./data/characters.js"></script>
    <script src="./data/revelations.js"></script>
    <script src="./data/rituals.js"></script>
    <script src="./data/weapons.js"></script>
    <script src="./data/persona.js"></script>
    <script src="./data/skills.js"></script>
    <!-- 공유 데이터 처리 함수 -->
    <script src="./js/share.js"></script>
</head>
<body>
  <div class="container">
    <div class="header-container">
      <div class="logo-container"> <!-- 현재 페이지로 하이퍼링크 걸기 -->
        <a href="./index.html">
          <img src="./img/logo/P5Xlogo.png" alt="Persona5X Logo" />
        </a>
        <div style="display: flex; align-items: center;">
          <a href="./index.html" style="text-decoration: none;">
            <h1 style="color: white;">페르소나5X 택틱 메이커</h1>
          </a>
        </div>
      </div>
      <div class="top-buttons">
        <button class="export-import-btn" onclick="exportData()">내보내기</button>
        <button class="export-import-btn" onclick="importData()">가져오기</button>
        <button class="export-import-btn" onclick="handleShare()">공유하기</button>
        <button class="export-import-btn toggle-ui-btn" onclick="toggleUI()"></button>
      </div>
    </div>
    
    <!-- 상단 컨테이너: (1) 원더 설정, (2) 파티 선택 -->
    <div id="top-container">
      <!-- 원더 설정 카드 -->
      <div class="card wonder-setting" id="wonder-config">
        <h2>원더 설정</h2>
        <div class="weapon-container">
          <label>무기:
            <input type="text" class="wonder-weapon-input" list="weapon-list" placeholder="선택 또는 입력" />
          </label>
          <datalist id="weapon-list">
            <!-- JavaScript에서 동적으로 채워짐 -->
          </datalist>
        </div>
        <div class="persona-container">
          <label>페르소나1:
            <input type="text" class="wonder-persona-input" data-persona-index="0" />
          </label>
          <input type="text" class="persona-skill-input" data-persona-index="0" placeholder="스킬 세팅" />
        </div>
        <div class="persona-container">
          <label>페르소나2:
            <input type="text" class="wonder-persona-input" data-persona-index="1" />
          </label>
          <input type="text" class="persona-skill-input" data-persona-index="1" placeholder="스킬 세팅" />
        </div>
        <div class="persona-container">
          <label>페르소나3:
            <input type="text" class="wonder-persona-input" data-persona-index="2" />
          </label>
          <input type="text" class="persona-skill-input" data-persona-index="2" placeholder="스킬 세팅" />
        </div>
      </div>
      
      <!-- 파티 선택 카드 -->
      <div class="card" id="party-selection">
        <h2>괴도단</h2>
        <div class="party-member" data-index="0">
          <div class="input-group">
            <label>괴도 1</label>
            <select class="party-name">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>의식:</label>
            <select class="party-ritual" style="width: 50px;">
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="input-group">
            <label>순서:</label>
            <select class="party-order" style="width: 50px;">
              <option value="1" selected>1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="input-group">
            <label>주 계시:</label>
            <select class="main-revelation">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>일월성진:</label>
            <select class="sub-revelation" disabled>
              <option value="">-</option>
            </select>
          </div>
        </div>
        <div class="party-member" data-index="1">
          <div class="input-group">
            <label>괴도 2</label>
            <select class="party-name">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>의식:</label>
            <select class="party-ritual" style="width: 50px;">
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="input-group">
            <label>순서:</label>
            <select class="party-order" style="width: 50px;">
              <option value="1">1</option>
              <option value="2" selected>2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="input-group">
            <label>주 계시:</label>
            <select class="main-revelation">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>일월성진:</label>
            <select class="sub-revelation" disabled>
              <option value="">-</option>
            </select>
          </div>
        </div>
        <div class="party-member" data-index="2">
          <div class="input-group">
            <label>괴도 3</label>
            <select class="party-name">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>의식:</label>
            <select class="party-ritual" style="width: 50px;">
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="input-group">
            <label>순서:</label>
            <select class="party-order" style="width: 50px;">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="input-group">
            <label>주 계시:</label>
            <select class="main-revelation">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>일월성진:</label>
            <select class="sub-revelation" disabled>
              <option value="">-</option>
            </select>
          </div>
        </div>
        <div class="party-member" data-index="3">
          <div class="input-group">
            <label>괴도 4</label>
            <select class="party-name">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>의식:</label>
            <select class="party-ritual" style="width: 50px;">
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="input-group">
            <label>순서:</label>
            <select class="party-order" style="width: 50px;">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4" selected>4</option>
            </select>
          </div>
          <div class="input-group">
            <label>주 계시:</label>
            <select class="main-revelation">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>일월성진:</label>
            <select class="sub-revelation" disabled>
              <option value="">-</option>
            </select>
          </div>
        </div>
        <div class="party-member" data-index="4">
          <div class="input-group">
            <label>해명 -</label>
            <select class="party-name">
              <option value="">-</option>
              <!-- supportParty 목록은 JavaScript에서 동적으로 채워짐 -->
            </select>
          </div>
          <div class="input-group">
            <label>의식:</label>
            <select class="party-ritual" style="width: 50px;">
              <option value="0" selected>0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="input-group">
            <label>순서:</label>
            <select class="party-order" style="width: 50px;">
              <option value="-" selected>-</option>
            </select>
          </div>
          <div class="input-group">
            <label>주 계시:</label>
            <select class="main-revelation">
              <option value="">-</option>
            </select>
          </div>
          <div class="input-group">
            <label>일월성진:</label>
            <select class="sub-revelation" disabled>
              <option value="">-</option>
            </select>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 파티 이미지를 위한 새로운 컨테이너 -->
    <div class = "middle-contianer">
      <div class="party-images-container">
        <div class="party-images"></div>
      </div>
      <div class="madeby">by 루트</div>
    </div>

    <!-- 턴 영역 (6턴) -->
    <div id="turns"></div>
    
    <!-- SortableJS (드래그앤드롭 라이브러리) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script>
      /* ========== 전역 데이터 ========== */
      // 원더의 페르소나 3칸
      let wonderPersonas = ["","",""];
      
      // 파티원 정보 (5명)
      let partyMembers = [
        { index: 0, name: "원더", order: "1", ritual: "" },
        { index: 1, name: "", order: "2", ritual: "" },
        { index: 2, name: "", order: "3", ritual: "" },
        { index: 3, name: "", order: "4", ritual: "" },
        { index: 4, name: "", order: "-", ritual: "" }
      ];
      
      // 턴 데이터(6턴). 각 턴에는 actions 배열(자동+수동 구분)만 둔다.
      let turns = [];
      for (let i = 0; i < 6; i++) {
        turns.push({
          turn: i + 1,
          actions: [
            /* 예: { type: 'auto', character: '원더', action: '', wonderPersona: '' } */
          ]
        });
      }


      // 의식 레벨에 맞는 패턴을 찾는 함수 수정
      function findPatternForLevel(characterName, ritualLevel) {
        const characterPatterns = ritualPatterns[characterName];
        if (!characterPatterns) return null;

        const matchingPattern = characterPatterns.find(patternData => {
          if (patternData.level.includes('-')) {
            const [min, max] = patternData.level.split('-').map(Number);
            const level = Number(ritualLevel);
            return level >= min && level <= max;
          } else {
            return patternData.level === ritualLevel;
          }
        });

        return matchingPattern ? matchingPattern.pattern : null;
      }
      
      // DOM이 로드되면 초기 설정
      document.addEventListener("DOMContentLoaded", () => {
        const urlParams = new URLSearchParams(window.location.search);
        const sharedData = urlParams.get('data');
        
        if (sharedData) {
          const decodedData = processSharedData(sharedData);
          if (decodedData) {
            // 원더 페르소나 데이터 설정
            wonderPersonas = decodedData.w;
            
            // 원더 설정 UI 업데이트
            const wonderInputs = document.querySelectorAll(".wonder-persona-input");
            wonderInputs.forEach((input, idx) => {
              input.value = wonderPersonas[idx] || "";
            });

            // 원더 무기 설정
            document.querySelector(".wonder-weapon-input").value = decodedData.weapon;

            // 페르소나 스킬 설정
            const skillInputs = document.querySelectorAll(".persona-skill-input");
            decodedData.personaSkills.forEach((skill, idx) => {
              if (skillInputs[idx]) skillInputs[idx].value = skill;
            });
            
            // partyMembers 데이터 복원
            decodedData.p.forEach((p, idx) => {
              partyMembers[idx].name = p.name;
              partyMembers[idx].order = p.order;
              partyMembers[idx].ritual = p.ritual;
              
              // 파티원 이름 입력 필드 업데이트
              const partyDiv = document.querySelector(`.party-member[data-index="${idx}"]`);
              if (partyDiv) {
                const nameInput = partyDiv.querySelector(".party-name-input");
                const orderSelect = partyDiv.querySelector(".party-order");
                const ritualSelect = partyDiv.querySelector(".party-ritual");
                const mainRevSelect = partyDiv.querySelector(".main-revelation");
                const subRevSelect = partyDiv.querySelector(".sub-revelation");
                
                if (nameInput) nameInput.value = p.name || "";
                if (orderSelect) orderSelect.value = p.order || "";
                if (ritualSelect) ritualSelect.value = p.ritual || "0";
                
                // 계시 설정
                if (mainRevSelect && p.mainRev) {
                  mainRevSelect.value = p.mainRev;
                  // 주 계시가 선택되었을 때 일월성진 활성화
                  if (p.mainRev && revelationData.main[p.mainRev]) {
                    subRevSelect.disabled = false;
                    // 일월성진 옵션 설정
                    subRevSelect.innerHTML = '<option value="">-</option>';
                    revelationData.main[p.mainRev].forEach(subRev => {
                      const opt = document.createElement("option");
                      opt.value = subRev;
                      opt.textContent = subRev;
                      subRevSelect.appendChild(opt);
                    });
                    // 일월성진 값 설정
                    if (p.subRev) {
                      subRevSelect.value = p.subRev;
                    }
                  }
                }
                
                // 원더일 경우 의식과 계시 비활성화
                if (p.n === "원더") {
                  if (ritualSelect) {
                    ritualSelect.disabled = true;
                    ritualSelect.value = "0";
                  }
                  if (mainRevSelect) mainRevSelect.disabled = true;
                  if (subRevSelect) subRevSelect.disabled = true;
                }
              }
            });
            
            // 턴 데이터 복원
            turns = decodedData.t;
            
            // UI 기본 설정
            setupWonderConfig();
            setupPartySelection();

            // 계시값 재설정
            decodedData.p.forEach((p, idx) => {
              const partyDiv = document.querySelector(`.party-member[data-index="${idx}"]`);
              if (partyDiv && p.mainRev) {
                const mainRevSelect = partyDiv.querySelector(".main-revelation");
                const subRevSelect = partyDiv.querySelector(".sub-revelation");
                
                if (mainRevSelect) {
                  mainRevSelect.value = p.mainRev;
                  
                  if (revelationData.main[p.mainRev]) {
                    subRevSelect.disabled = false;
                    subRevSelect.innerHTML = '<option value="">-</option>';
                    revelationData.main[p.mainRev].forEach(subRev => {
                      const opt = document.createElement("option");
                      opt.value = subRev;
                      opt.textContent = subRev;
                      subRevSelect.appendChild(opt);
                    });
                    
                    if (p.subRev) {
                      subRevSelect.value = p.subRev;
                    }
                  }
                }
              }
            });

            updatePartyImages();
            
            // 턴 렌더링 (자동 액션 업데이트 전)
            renderTurns();
            
            // 각 턴의 액션 데이터 복원
            turns.forEach((turn, turnIndex) => {
              const turnContainer = document.querySelector(`.turn-container[data-turn-index="${turnIndex}"]`);
              if (!turnContainer) return;

              const actionsList = turnContainer.querySelector('.actions');
              if (!actionsList) return;

              turn.actions.forEach((action, actionIndex) => {
                const actionItem = actionsList.children[actionIndex];
                if (!actionItem) return;

                // 캐릭터 선택
                const charSelect = actionItem.querySelector('.action-character');
                if (charSelect) {
                  charSelect.value = action.character;
                }

                // 원더 페르소나 또는 스킬 선택
                if (action.character === "원더") {
                  const personaSelect = actionItem.querySelector('.wonder-persona-select');
                  if (personaSelect) {
                    personaSelect.value = action.wonderPersona;
                  }
                } else {
                  const skillSelect = actionItem.querySelector('.action-skill');
                  if (skillSelect) {
                    skillSelect.value = action.action;
                  }
                }

                // 메모 입력
                const memoInput = actionItem.querySelector('.action-memo');
                if (memoInput) {
                  memoInput.value = action.memo || "";
                }
              });
            });
            
            // 마지막으로 자동 액션 업데이트
            updateAutoActions();
            
          } 
        } else {
          setupWonderConfig();
          setupPartySelection();
          updateAutoActions();
          updatePartyImages();
          renderTurns();
        }
      });


      /* ========== 원더 설정 ========== */
      function setupWonderConfig() {
        const wonderConfigDiv = document.getElementById("wonder-config");
        
        // 무기 입력 필드 수정
        const weaponInput = wonderConfigDiv.querySelector(".wonder-weapon-input");
        const weaponContainer = weaponInput.parentElement;
        
        // input을 컨테이너로 감싸기
        const inputContainer = document.createElement("div");
        inputContainer.className = "input-container";
        
        // 기존 input을 새 컨테이너로 이동
        weaponInput.parentNode.insertBefore(inputContainer, weaponInput);
        inputContainer.appendChild(weaponInput);
        
        // clear 버튼 추가
        const clearBtn = document.createElement("button");
        clearBtn.className = "clear-input";
        clearBtn.textContent = "×";
        clearBtn.addEventListener("click", () => {
          weaponInput.value = "";
          weaponInput.focus();
        });
        inputContainer.appendChild(clearBtn);

        const inputs = wonderConfigDiv.querySelectorAll(".wonder-persona-input");
        
        const weaponList = document.getElementById("weapon-list");
        wonderWeapons.forEach(weapon => {
          const option = document.createElement("option");
          option.value = weapon;
          weaponList.appendChild(option);
        });

        // 디바운스 함수
        const debounce = (func, wait) => {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        };
        
        // 업데이트 함수를 디바운스 처리
        const debouncedUpdate = debounce(() => {
          updateAutoActions();
          updatePartyImages();
          renderTurns();
        }, 300);
        
        inputs.forEach((input, idx) => {
          // input을 컨테이너로 감싸기
          const inputContainer = document.createElement("div");
          inputContainer.className = "input-container";
          
          // datalist 생성
          const datalistId = `persona-list-${idx}`;
          input.setAttribute("list", datalistId);
          input.placeholder = "선택 또는 입력";
          
          const datalist = document.createElement("datalist");
          datalist.id = datalistId;
          
          // 페르소나 옵션 추가
          personaList.forEach(persona => {
            const option = document.createElement("option");
            option.value = persona;
            datalist.appendChild(option);
          });
          
          // clear 버튼 추가
          const clearBtn = document.createElement("button");
          clearBtn.className = "clear-input";
          clearBtn.textContent = "×";
          clearBtn.addEventListener("click", () => {
            input.value = "";
            wonderPersonas[idx] = "";
            debouncedUpdate();
            input.focus();
          });
          
          // 요소들을 컨테이너에 추가
          input.parentNode.insertBefore(inputContainer, input);
          inputContainer.appendChild(input);
          inputContainer.appendChild(clearBtn);
          inputContainer.parentNode.appendChild(datalist);
          
          // input 이벤트 리스너 수정
          input.addEventListener("change", (e) => {
            const oldPersona = wonderPersonas[idx];
            const newPersona = e.target.value;
            wonderPersonas[idx] = newPersona;
            
            // 턴 데이터에서 해당 페르소나 업데이트
            turns.forEach(turn => {
              turn.actions.forEach(action => {
                if (action.character === "원더" && action.wonderPersona === oldPersona) {
                  action.wonderPersona = newPersona || `페르소나${idx + 1}`;
                }
              });
            });
            
            debouncedUpdate();
          });

          // input 직접 입력 이벤트도 추가
          input.addEventListener("input", (e) => {
            const oldPersona = wonderPersonas[idx];
            const newPersona = e.target.value;
            wonderPersonas[idx] = newPersona;
            
            // 턴 데이터에서 해당 페르소나 업데이트
            turns.forEach(turn => {
              turn.actions.forEach(action => {
                if (action.character === "원더" && action.wonderPersona === oldPersona) {
                  action.wonderPersona = newPersona || `페르소나${idx + 1}`;
                }
              });
            });
            
            debouncedUpdate();
          });
        });

        // 무기 입력 필드 이벤트 리스너 수정
        weaponInput.addEventListener("change", (e) => {
          updatePartyImages();
        });

        weaponInput.addEventListener("input", (e) => {
          updatePartyImages();
        });
      }
      
      /* ========== 파티 선택 ========== */
      function setupPartySelection() {
        const partyDivs = document.querySelectorAll(".party-member");
        
        partyDivs.forEach(div => {
          const index = parseInt(div.getAttribute("data-index"), 10);
          const nameSelect = div.querySelector(".party-name");
          const mainRevSelect = div.querySelector(".main-revelation");
          const subRevSelect = div.querySelector(".sub-revelation");
          const orderSelect = div.querySelector(".party-order");
          const ritualSelect = div.querySelector(".party-ritual");
          
          // 초기 원더 설정에 대한 비활성화 처리
          if (partyMembers[index].name === "원더") {
            ritualSelect.disabled = true;
            ritualSelect.value = "0";
            mainRevSelect.disabled = true;
            mainRevSelect.value = "";
            subRevSelect.disabled = true;
            subRevSelect.value = "";
            
            partyMembers[index].ritual = "0";
          }
          
          // 주 계시 옵션 설정
          if (mainRevSelect) {
            // 기존 옵션 초기화
            mainRevSelect.innerHTML = '<option value="">-</option>';
            
            // 주 계시 옵션 추가
            Object.keys(revelationData.main).forEach(rev => {
              const opt = document.createElement("option");
              opt.value = rev;
              opt.textContent = rev;
              mainRevSelect.appendChild(opt);
            });

            // 주 계시 변경 이벤트
            mainRevSelect.addEventListener("change", (e) => {
              const selectedMain = e.target.value;
              
              // 일월성진 드롭다운 활성화/비활성화
              if (selectedMain && revelationData.main[selectedMain]) {
                subRevSelect.disabled = false;
                
                // 일월성진 옵션 설정
                subRevSelect.innerHTML = '<option value="">-</option>';
                revelationData.main[selectedMain].forEach(subRev => {
                  const opt = document.createElement("option");
                  opt.value = subRev;
                  opt.textContent = subRev;
                  subRevSelect.appendChild(opt);
                });
              } else {
                subRevSelect.disabled = true;
                subRevSelect.innerHTML = '<option value="">-</option>';
              }
              
              // 파티 이미지 업데이트 추가
              updatePartyImages();
            });
            //일월성진 변경 시 
            subRevSelect.addEventListener("change", (e) => {
              // 파티 이미지 업데이트 추가
              updatePartyImages();
            });
          }

          if (nameSelect) {
            // input container 생성
            const inputContainer = document.createElement("div");
            inputContainer.className = "input-container";
            
            // input 요소 생성
            const input = document.createElement("input");
            input.setAttribute("list", `characters-${index}`);
            input.className = "party-name-input";
            input.value = partyMembers[index].name;
            input.placeholder = "선택 또는 입력";
            
            // datalist 생성
            const datalist = document.createElement("datalist");
            datalist.id = `characters-${index}`;
            
            // 캐릭터 옵션 추가
            const characterOptions = index === 4 ? characterList.supportParty : characterList.mainParty;
            characterOptions.forEach(char => {
              const option = document.createElement("option");
              option.value = char;
              datalist.appendChild(option);
            });
            
            // clear 버튼 생성
            const clearBtn = document.createElement("button");
            clearBtn.className = "clear-input";
            clearBtn.textContent = "×";
            clearBtn.addEventListener("click", () => {
              input.value = "";
              const oldName = partyMembers[index].name;
              partyMembers[index].name = "";
              
              // 해당 캐릭터의 자동 액션 삭제
              turns.forEach(turn => {
                turn.actions = turn.actions.filter(action => 
                  action.type === 'manual' || action.character !== oldName
                );
              });
              
              updateAutoActions();
              updatePartyImages();
              renderTurns();
              input.focus();
            });
            
            // 요소들을 컨테이너에 추가
            inputContainer.appendChild(input);
            inputContainer.appendChild(clearBtn);
            
            // select를 새로운 input container로 교체
            nameSelect.parentNode.replaceChild(inputContainer, nameSelect);
            div.appendChild(datalist);
            
            // input 이벤트 리스너 수정
            input.addEventListener("change", (e) => {
              const oldName = partyMembers[index].name;
              const selectedName = e.target.value;
              const currentRitual = ritualSelect.value;
              partyMembers[index].name = selectedName;
              
              // 턴 데이터에서 해당 캐릭터 업데이트
              turns.forEach(turn => {
                turn.actions.forEach(action => {
                  if (action.character === oldName) {
                    action.character = selectedName || "";
                  }
                });
              });
              
              // 원더일 경우 의식과 주 계시 비활성화
              if (selectedName === "원더") {
                ritualSelect.disabled = true;
                ritualSelect.value = "0";
                mainRevSelect.disabled = true;
                mainRevSelect.value = "";
                subRevSelect.disabled = true;
                subRevSelect.value = "";
                
                partyMembers[index].ritual = "0";
              } else {
                ritualSelect.disabled = false;
                mainRevSelect.disabled = false;
                
                // 캐릭터의 기본 계시 값 설정
                if (characterData[selectedName]) {
                  const charData = characterData[selectedName];
                  
                  // 주 계시 설정
                  if (charData.main_revelation) {
                    mainRevSelect.value = charData.main_revelation;
                    
                    // 일월성진 옵션 설정
                    if (revelationData.main[charData.main_revelation]) {
                      subRevSelect.disabled = false;
                      subRevSelect.innerHTML = '<option value="">-</option>';
                      revelationData.main[charData.main_revelation].forEach(subRev => {
                        const opt = document.createElement("option");
                        opt.value = subRev;
                        opt.textContent = subRev;
                        subRevSelect.appendChild(opt);
                      });
                      
                      // 일월성진 값 설정
                      if (charData.sub_revelation) {
                        subRevSelect.value = charData.sub_revelation;
                      }
                    }
                  }
                }
                
                // 새로 선택된 캐릭터의 의식 패턴이 있는지 확인
                if (ritualPatterns[selectedName]) {
                  const pattern = findPatternForLevel(selectedName, currentRitual);
                  if (pattern) {
                    turns.forEach((turn, turnIndex) => {
                        // 해당 캐릭터의 기존 자동 액션 제거
                        turn.actions = turn.actions.filter(action => 
                          !(action.type === 'auto' && action.character === selectedName)
                        );
                        
                        // 해당 턴의 패턴이 있고 빈 배열이 아닌 경우에만 액션 추가
                        if (pattern[turnIndex] && pattern[turnIndex].length > 0) {
                          pattern[turnIndex].forEach(actionData => {
                            if (actionData.order === 0) {
                              turn.actions.unshift({
                                type: 'auto',
                                character: selectedName,
                                action: actionData.type,
                                wonderPersona: "",
                                memo: ""
                              });
                            } else {
                              turn.actions.push({
                                type: 'auto',
                                character: selectedName,
                                action: actionData.type,
                                wonderPersona: "",
                                memo: ""
                              });
                            }
                        });
                      }
                    });
                  }
                }
                else{
                  updateAutoActions();
                }
              }
              //updateAutoActions();
              updatePartyImages();
              renderTurns();
            });

            // input 직접 입력 이벤트도 추가
            input.addEventListener("input", (e) => {
              const selectedName = e.target.value;
              const currentRitual = ritualSelect.value;
              partyMembers[index].name = selectedName;
              
              // 원더일 경우 의식과 계시 비활성화
              if (selectedName === "원더") {
                ritualSelect.disabled = true;
                ritualSelect.value = "0";
                mainRevSelect.disabled = true;
                mainRevSelect.value = "";
                subRevSelect.disabled = true;
                subRevSelect.value = "";
                
                partyMembers[index].ritual = "0";
              } else {
                ritualSelect.disabled = false;
                mainRevSelect.disabled = false;
                
                // 새로 선택된 캐릭터의 의식 패턴이 있는지 확인
                if (ritualPatterns[selectedName]) {
                  const pattern = findPatternForLevel(selectedName, currentRitual);
                  if (pattern) {
                    turns.forEach((turn, turnIndex) => {
                        // 해당 캐릭터의 기존 자동 액션 제거
                        turn.actions = turn.actions.filter(action => 
                          !(action.type === 'auto' && action.character === selectedName)
                        );
                        
                        // 해당 턴의 패턴이 있고 빈 배열이 아닌 경우에만 액션 추가
                        if (pattern[turnIndex] && pattern[turnIndex].length > 0) {
                          pattern[turnIndex].forEach(actionData => {
                            if (actionData.order === 0) {
                              turn.actions.unshift({
                                type: 'auto',
                                character: selectedName,
                                action: actionData.type,
                                wonderPersona: "",
                                memo: ""
                              });
                            } else {
                              turn.actions.push({
                                type: 'auto',
                                character: selectedName,
                                action: actionData.type,
                                wonderPersona: "",
                                memo: ""
                              });
                            }
                        });
                      }
                    });
                  }
                }
              }
              
              updateAutoActions();
              updatePartyImages();
              renderTurns();
            });
          }

          // 순서 변경 시 이벤트
          orderSelect.addEventListener("change", (e) => {
            const newOrder = e.target.value;
            const oldOrder = partyMembers[index].order;
            
            // 다른 멤버의 순서 조정
            if (newOrder !== "-") {
              const swappedMember = partyMembers.find(pm => pm.index !== index && pm.order === newOrder);
              if (swappedMember) {
                swappedMember.order = oldOrder;
                const otherSelect = document.querySelector(
                  `.party-member[data-index="${swappedMember.index}"] .party-order`
                );
                if (otherSelect) otherSelect.value = oldOrder;
              }
            }
            
            partyMembers[index].order = newOrder;
            
            // 턴 데이터의 순서 업데이트
            turns.forEach(turn => {
              // 1. 순서 변경이 불가한 액션들 분리
              const fixedActions = turn.actions.filter(action => 
                action.action === 'HIGHLIGHT' || 
                action.action === 'ONE MORE' ||
                partyMembers.find(pm => pm.name === action.character)?.index === 4
              );
              
              // 2. 순서 변경이 가능한 액션들 분리
              const sortableActions = turn.actions.filter(action => 
                !fixedActions.includes(action)
              );
              
              // 3. 파티 순서대로 정렬
              const sortedParty = partyMembers
                .filter(pm => pm.name !== "" && pm.index !== 4)  // 해명 괴도 제외
                .sort((a, b) => {
                  if (a.order === "-") return 1;
                  if (b.order === "-") return -1;
                  return parseInt(a.order, 10) - parseInt(b.order, 10);
                });
              
              // 4. 순서 변경이 가능한 액션들을 파티 순서대로 재정렬
              const sortedActions = [];
              sortedParty.forEach(member => {
                // 해당 캐릭터의 모든 액션을 순서대로 가져옴
                const characterActions = sortableActions.filter(a => a.character === member.name);
                sortedActions.push(...characterActions);  // 연속된 행동 순서 유지
              });
              
              // 5. 최종 액션 배열 구성
              // 고정 액션들은 원래 위치 유지, 정렬된 액션들 추가
              const finalActions = [];
              turn.actions.forEach(action => {
                if (fixedActions.includes(action)) {
                  finalActions.push(action);
                }
              });
              finalActions.push(...sortedActions);
              
              turn.actions = finalActions;
            });
            
            updatePartyImages();
            renderTurns();
          });

          // 의식 변경 이벤트 리스너 수정
          ritualSelect.addEventListener("change", (e) => {
            const newRitual = e.target.value;
            const characterName = partyMembers[index].name;
            partyMembers[index].ritual = newRitual;
            
            if (ritualPatterns[characterName]) {
              const pattern = findPatternForLevel(characterName, newRitual);
              if (pattern) {
                turns.forEach((turn, turnIndex) => {
                  // 해당 캐릭터의 기존 자동 액션 제거
                  turn.actions = turn.actions.filter(action => 
                    !(action.type === 'auto' && action.character === characterName)
                  );
                  
                  // 해당 턴의 패턴이 있고 빈 배열이 아닌 경우에만 액션 추가
                  if (pattern[turnIndex] && pattern[turnIndex].length > 0) {
                    pattern[turnIndex].forEach(actionData => {
                      if (actionData.order === 0) {
                        turn.actions.unshift({
                          type: 'auto',
                          character: characterName,
                          action: actionData.type,
                          wonderPersona: "",
                          memo: ""
                        });
                      } else {
                        turn.actions.push({
                          type: 'auto',
                          character: characterName,
                          action: actionData.type,
                          wonderPersona: "",
                          memo: ""
                        });
                      }
                    });
                  }
                });
                
                renderTurns();
              }
            }
            
            updatePartyImages();
          });
        });

      }
      
      /* ========== 자동 액션 업데이트 ========== */
      function updateAutoActions() {
        // URL 파라미터에 data가 있는 경우에만 자동 업데이트를 건너뜀
     //   if (new URLSearchParams(window.location.search).has('data')) {
     //     return;
     //   }

        turns.forEach(turn => {
          // 기존 액션들을 유지
          const existingActions = [...turn.actions];
          
          // 현재 파티 멤버들의 순서대로 정렬된 배열 
          const sortedParty = partyMembers
            .filter(pm => pm.name !== "") 
            .sort((a, b) => parseInt(a.order, 10) - parseInt(b.order, 10));

          // 자동 액션 업데이트
          let updatedActions = existingActions.map(action => {  // const를 let으로 변경
            if (action.type === 'manual') {
              return action;
            }
            
            // 자동 액션의 경우, 해당 캐릭터가 현재 파티에 없으면 제거
            if (!sortedParty.some(pm => pm.name === action.character)) {
              return null;
            }
            
            return action;
          }).filter(action => action !== null);

          // 새로운 파티원에 대한 자동 액션 추가
          sortedParty.forEach(member => {
            if (!updatedActions.some(action => action.character === member.name)) {
              updatedActions.push({
                type: 'auto',
                character: member.name,
                wonderPersona: "",
                action: "",
                memo: ""
              });
            }
          });

          // 해명괴도의 빈칸 action 삭제
          updatedActions = updatedActions.filter(action => {
            const member = partyMembers.find(pm => pm.name === action.character);
            if (member?.index === 4 && !action.action) {
              return false;
            }
            return true;
          });

          // 자동 액션 순서 재정렬
          const finalActions = [];
          const processedActions = new Set(); // 처리된 액션 처리
          
          // order 0인 자동 액션 먼저 추가
          sortedParty.forEach(member => {
            const pattern = findPatternForLevel(member.name, member.ritual);
            const turnIndex = turns.indexOf(turn);
            if (pattern && pattern[turnIndex]) {
              const hasOrder0 = pattern[turnIndex].some(action => action.order === 0);
              if (hasOrder0) {
                const autoAction = updatedActions.find(
                  action => action.type === 'auto' && action.character === member.name
                );
                if (autoAction && !processedActions.has(autoAction)) {
                  finalActions.unshift(autoAction);
                  processedActions.add(autoAction); // 처리된 액션 기록
                }
              }
            }
          });
          
          // 나머지 자동 액션 추가
          sortedParty.forEach(member => {
            const autoAction = updatedActions.find(
              action => action.type === 'auto' && action.character === member.name
            );
            if (autoAction && !processedActions.has(autoAction)) {
              finalActions.push(autoAction);
              processedActions.add(autoAction); // 처리된 액션 기록
            }
          });
          
          // 수동 액션 추가
          updatedActions
            .filter(action => action.type === 'manual')
            .forEach(action => finalActions.push(action));

          turn.actions = finalActions;
        });
        
        renderTurns();
      }
      
      /* ========== 전체 렌더링 ========== */
      function renderTurns() {
        const turnsContainer = document.getElementById("turns");
        turnsContainer.innerHTML = "";
        
        // 턴 순서 재배열 (1-2, 3-4, 5-6 순서로)
        const turnPairs = [
          [turns[0], turns[3]], // 1-2턴
          [turns[1], turns[4]], // 3-4턴
          [turns[2], turns[5]]  // 5-6턴
        ];
        
        turnPairs.forEach(pair => {
          pair.forEach(turn => {
            const turnDiv = document.createElement("div");
            turnDiv.className = "turn-container";
            turnDiv.setAttribute("data-turn-index", turns.indexOf(turn));
            
            // 턴 헤더 컨테이너
            const headerContainer = document.createElement("div");
            headerContainer.className = "turn-header-container";
            
            // 턴 헤더
            const header = document.createElement("div");
            header.className = "turn-header";
            header.textContent = `${turn.turn}턴`;
            headerContainer.appendChild(header);
            
            // + 버튼
            const addBtn = document.createElement("button");
            addBtn.className = "add-action";
            addBtn.textContent = "+";
            addBtn.addEventListener("click", () => {
              // 해명 괴도가 설정되어 있는지 확인
              const supportMember = partyMembers.find(pm => pm.index === 4 && pm.name !== "");
              
              turn.actions.push({
                type: 'manual',
                character: supportMember ? supportMember.name : "",  // 해명 괴도가 있으면 자동으로 설정
                wonderPersona: "",
                action: "",
                memo: ""
              });
              renderTurns();
            });
            headerContainer.appendChild(addBtn);
            
            turnDiv.appendChild(headerContainer);
            
            // 액션 리스트
            const actionsList = document.createElement("ul");
            actionsList.className = "actions";
            
            turn.actions.forEach((action, aIndex) => {
              const li = createActionRow(turns.indexOf(turn), aIndex);
              actionsList.appendChild(li);
            });
            
            turnDiv.appendChild(actionsList);
            
            turnsContainer.appendChild(turnDiv);
          });
        });
        
        // (A) 턴 자체의 드래그앤드롭 (턴 순서 변경)
        Sortable.create(turnsContainer, {
          animation: 150,
          handle: ".turn-header",
          onEnd: function() {
            // 현재 화면 순서에 맞춰 turns 배열 재정렬
            const newTurnArr = [];
            const turnDivs = turnsContainer.querySelectorAll(".turn-container");
            turnDivs.forEach(div => {
              const idx = parseInt(div.getAttribute("data-turn-index"), 10);
              newTurnArr.push(turns[idx]);
            });
            // 새 순서에 맞춰 턴 번호 재할당
            newTurnArr.forEach((turn, i) => {
              turn.turn = i + 1;
            });
            turns = newTurnArr;
            renderTurns();
          }
        });
        
        // (B) 각 턴 내부 액션 리스트의 드래그앤드롭
        const actionLists = document.querySelectorAll(".actions");
        actionLists.forEach(list => {
          Sortable.create(list, {
            animation: 150,
            group: 'actions',
            onEnd: function(evt) {
              const fromTurnIndex = parseInt(evt.from.closest('.turn-container').dataset.turnIndex);
              const toTurnIndex = parseInt(evt.to.closest('.turn-container').dataset.turnIndex);
              
              // 드래그된 액션의 원본 데이터 저장
              const movedAction = {...turns[fromTurnIndex].actions[parseInt(evt.item.dataset.actionIndex)]};
              
              // 새로운 순서로 액션 배열 재구성
              const fromActions = Array.from(evt.from.children).map(item => {
                const index = parseInt(item.dataset.actionIndex);
                return index === parseInt(evt.item.dataset.actionIndex) ? movedAction : turns[fromTurnIndex].actions[index];
              });
              
              const toActions = fromTurnIndex === toTurnIndex ? fromActions : 
                Array.from(evt.to.children).map(item => {
                  const index = parseInt(item.dataset.actionIndex);
                  return item === evt.item ? movedAction : turns[toTurnIndex].actions[index];
                });
              
              turns[fromTurnIndex].actions = fromActions;
              if(fromTurnIndex !== toTurnIndex) {
                turns[toTurnIndex].actions = toActions;
              }
              
              renderTurns();
            }
          });
        });
      }
      
      /* ========== 액션 행 생성 ========== */
      function createActionRow(turnIndex, actionIndex) {
        const action = turns[turnIndex].actions[actionIndex];
        const li = document.createElement("li");
        li.className = "action-item";
        li.setAttribute("data-action-index", actionIndex);
        
        // 캐릭터에 해당하는 배경색 적용
        if (action.character && characterData[action.character]) {
          li.style.backgroundColor = characterData[action.character].color + "30"; // 20은 투명도
        }
        
        // (1) 캐릭터 드롭다운
        const charSelect = document.createElement("select");
        charSelect.className = "action-character";
        
        // 드롭다운 옵션 채우기 - 현재 선택된 파티원들만 표시
        charSelect.innerHTML = '<option value="">참고사항</option>'; // 참고사항으로 변경
        const activePartyMembers = partyMembers
          .filter(member => member.name !== "") // 선택된 멤버만 필터링
          .map(member => member.name); // 이름만 추출
        
        activePartyMembers.forEach(char => {
          const opt = document.createElement("option");
          opt.value = char;
          opt.textContent = char;
          if (action.character === char) opt.selected = true;
          charSelect.appendChild(opt);
        });
        
        charSelect.addEventListener("change", e => {
          action.character = e.target.value;
          action.wonderPersona = ""; // 캐릭터 변경시 페르소나 초기화
          action.action = ""; // 액션 초기화
          renderTurns();
        });
        li.appendChild(charSelect);
        
        // (2) 원더일 경우 페르소나 선택, 아닐 경우 스킬 드롭다운으로 변경
        if (action.character === "원더") {
          const personaSelect = document.createElement("select");
          personaSelect.className = "wonder-persona-select";
          
          wonderPersonas.forEach((p, idx) => {
            const opt = document.createElement("option");
            opt.value = p;
            opt.textContent = p || `페르소나${idx + 1}`;
            if (action.wonderPersona === p) opt.selected = true;
            personaSelect.appendChild(opt);
          });
          
          personaSelect.addEventListener("change", e => {
            action.wonderPersona = e.target.value;
          });
          li.appendChild(personaSelect);
        } else if (action.character) {
          // 스킬 드롭다운으로 변경
          const skillSelect = document.createElement("select");
          skillSelect.className = "action-skill";
          
          // 기본 옵션 추가
          skillSelect.innerHTML = '<option value="">선택</option>';
          
          // 스킬 옵션 추가
          skillList.forEach(skill => {
            const option = document.createElement("option");
            option.value = skill;
            option.textContent = skill;
            if (action.action === skill) option.selected = true;
            skillSelect.appendChild(option);
          });
          
          skillSelect.addEventListener("change", e => {
            action.action = e.target.value;
          });
          
          li.appendChild(skillSelect);
        }
        
        // (3) 메모 입력 필드 추가
        const memoInput = document.createElement("input");
        memoInput.type = "text";
        memoInput.className = "action-memo";
        memoInput.placeholder = "세부사항";
        memoInput.value = action.memo || "";
        memoInput.addEventListener("input", e => {
          action.memo = e.target.value;
        });
        li.appendChild(memoInput);
        
        // 복제 버튼 추가
        const cloneBtn = document.createElement("button");
        cloneBtn.className = "clone-action";
        cloneBtn.innerHTML = ""; // 또는 "복제" 텍스트 사용
        cloneBtn.addEventListener("click", () => {
          const clonedAction = JSON.parse(JSON.stringify(action)); // 깊은 복사
          turns[turnIndex].actions.splice(actionIndex + 1, 0, clonedAction);
          renderTurns();
        });
        
        // 삭제 버튼
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-action";
        deleteBtn.textContent = "×";
        deleteBtn.addEventListener("click", () => {
          turns[turnIndex].actions.splice(actionIndex, 1);
          renderTurns();
        });
        
        // 버튼 컨테이너 (복제 + 삭제)
        const btnContainer = document.createElement("div");
        btnContainer.className = "action-buttons";
        btnContainer.appendChild(cloneBtn);
        btnContainer.appendChild(deleteBtn);
        li.appendChild(btnContainer);
        
        return li;
      }

      // 파티 이미지 업데이트 함수
      function updatePartyImages() {
        const partyImagesContainer = document.querySelector(".party-images-container");
        partyImagesContainer.innerHTML = "";

        // 파티 이미지 컨테이너
        const partyImagesDiv = document.createElement("div");
        partyImagesDiv.className = "party-images";

        // 기존 파티 이미지 로직
        const orderedParty = partyMembers
          .filter(pm => pm.name !== "")
          .sort((a, b) => {
            if (a.order === "-") return 1;
            if (b.order === "-") return -1;
            return parseInt(a.order, 10) - parseInt(b.order, 10);
          });
        
        orderedParty.forEach((member) => {
          const container = document.createElement("div");
          container.className = "character-container";

          if (characterData[member.name]) {
            const charImg = document.createElement("img");
            charImg.className = "character-img";
            charImg.src = characterData[member.name].image;
            charImg.alt = member.name;
            charImg.title = member.name;
            container.appendChild(charImg);

            // 원더일 경우 무기 이미지 추가
            if (member.name === "원더") {
              const weaponInput = document.querySelector(".wonder-weapon-input");
              const selectedWeapon = weaponInput.value;
              
              if (selectedWeapon && wonderWeapons.includes(selectedWeapon)) {
                const weaponImg = document.createElement("img");
                weaponImg.className = "weapon-img";
                weaponImg.src = `./img/weapon/${selectedWeapon}.webp`;
                weaponImg.alt = selectedWeapon;
                weaponImg.title = selectedWeapon;
                container.appendChild(weaponImg);
              }
            }
          } else {
            // 이미지가 없는 경우 텍스트 원형으로 대체
            const textCircle = document.createElement("div");
            textCircle.className = "character-text-circle";
            textCircle.textContent = member.name;
            textCircle.title = member.name;
            container.appendChild(textCircle);
          }
          
          // 순서 이미지
          if (["1", "2", "3", "4"].includes(member.order)) {
            const orderImg = document.createElement("img");
            orderImg.className = "order-img";
            orderImg.src = `./img/ui/num0${member.order}.png`;
            orderImg.alt = `순서 ${member.order}`;
            container.appendChild(orderImg);
          }
          
          // 의식 이미지
          const ritualLevel = parseInt(member.ritual);
          if (ritualLevel >= 1 && ritualLevel <= 6) {
            const ritualImg = document.createElement("img");
            ritualImg.className = "ritual-img";
            ritualImg.src = `./img/ritual/num${ritualLevel}.png`;
            ritualImg.alt = `의식 ${ritualLevel}`;
            container.appendChild(ritualImg);
          }
          
          // 계시 이미지 추가
          const partyDiv = document.querySelector(`.party-member[data-index="${member.index}"]`);
          if (partyDiv) {
            const mainRev = partyDiv.querySelector(".main-revelation").value;
            const subRev = partyDiv.querySelector(".sub-revelation").value;
            
            if (mainRev && subRev) {
              const revelationsContainer = document.createElement("div");
              revelationsContainer.className = "revelations-container";

              const mainRevImg = document.createElement("img");
              mainRevImg.className = "revelation-img main-rev";
              mainRevImg.src = `./img/revelation/${mainRev}.webp`;
              mainRevImg.alt = mainRev;
              revelationsContainer.appendChild(mainRevImg);

              const subRevImg = document.createElement("img");
              subRevImg.className = "revelation-img sub-rev";
              subRevImg.src = `./img/revelation/${subRev}.webp`;
              subRevImg.alt = subRev;
              revelationsContainer.appendChild(subRevImg);

              container.appendChild(revelationsContainer);
            }
          }


          partyImagesDiv.appendChild(container);
        });

        partyImagesContainer.appendChild(partyImagesDiv);

        // 원더의 페르소나 이미지 추가
        if (wonderPersonas.some(persona => persona !== "")) {
          const personaImagesDiv = document.createElement("div");
          personaImagesDiv.className = "persona-images";

          wonderPersonas.forEach((persona, index) => {
            if (persona) {
              const container = document.createElement("div");
              container.className = "persona-container";

              const personaImg = document.createElement("img");
              personaImg.className = "persona-img";
              personaImg.src = `./img/persona/${persona}.webp`;
              personaImg.alt = persona;
              personaImg.title = `페르소나${index + 1}: ${persona}`;

              container.appendChild(personaImg);
              personaImagesDiv.appendChild(container);
            }
          });

          if (personaImagesDiv.children.length > 0) {
            partyImagesContainer.appendChild(personaImagesDiv);
          }
        }
      }

      // 데이터 내보내기 함수 수정
      function exportData() {
        const turnContainers = document.querySelectorAll('.turn-container');
        const currentTurns = new Array(6).fill(null);
        
        turnContainers.forEach(container => {
          const turnIndex = parseInt(container.getAttribute('data-turn-index'), 10);
          const turn = turns[turnIndex];
          const actionsList = container.querySelector('.actions');
          const actions = [];
          
          actionsList.querySelectorAll('li').forEach(actionItem => {
            const charSelect = actionItem.querySelector('.action-character');
            const personaSelect = actionItem.querySelector('.wonder-persona-select');
            const skillSelect = actionItem.querySelector('.action-skill');
            const memoInput = actionItem.querySelector('.action-memo');
            
            actions.push({
              m: actionItem.classList.contains('auto-action') ? 0 : 1, // type -> m
              c: charSelect ? charSelect.value : '', // character -> c
              w: personaSelect ? personaSelect.value : '', // wonderPersona -> w
              a: skillSelect ? skillSelect.value : '', // action -> a
              mm: memoInput ? memoInput.value : '' // memo -> mm
            });
          });
          
          currentTurns[turn.turn - 1] = {
            n: turn.turn, // turn -> n
            a: actions // actions -> a
          };
        });

        const data = {
          w: wonderPersonas,
          wp: document.querySelector(".wonder-weapon-input").value, // weapon -> wp
          ps: Array.from(document.querySelectorAll(".persona-skill-input")).map(input => input.value), // personaSkills -> ps
          p: partyMembers.map((pm, idx) => {
            const memberDiv = document.querySelector(`.party-member[data-index="${idx}"]`);
            return {
              n: pm.name,
              o: pm.order,
              r: pm.ritual,
              mr: memberDiv?.querySelector(".main-revelation")?.value || "", // mainRev -> mr
              sr: memberDiv?.querySelector(".sub-revelation")?.value || "" // subRev -> sr
            };
          }),
          t: currentTurns.filter(turn => turn !== null)
        };

        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'p5x_tactic.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // 데이터 가져오기 함수 수정
      function importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = function(e) {
          const file = e.target.files[0];
          const reader = new FileReader();
          
          reader.onload = function(e) {
            try {
              const data = JSON.parse(e.target.result);
              
              // 원더 페르소나 데이터 설정
              wonderPersonas = data.w;
              
              // 원더 설정 UI 업데이트
              const wonderInputs = document.querySelectorAll(".wonder-persona-input");
              wonderInputs.forEach((input, idx) => {
                input.value = wonderPersonas[idx] || "";
              });

              // 원더 무기 설정 (wp -> weapon)
              const weaponInput = document.querySelector(".wonder-weapon-input");
              if (data.wp) {
                weaponInput.value = data.wp;
              }

              // 페르소나 스킬 설정 (ps -> personaSkills)
              const skillInputs = document.querySelectorAll(".persona-skill-input");
              if (data.ps) {
                skillInputs.forEach((input, idx) => {
                  input.value = data.ps[idx] || "";
                });
              }
              
              // 턴 데이터 설정 - 압축된 형식을 원래 형식으로 변환
              turns = data.t.map(turn => ({
                turn: turn.n,
                actions: turn.a.map(action => ({
                  type: action.m ? 'manual' : 'auto',
                  character: action.c,
                  wonderPersona: action.w,
                  action: action.a,
                  memo: action.mm
                }))
              }));
              
              // partyMembers 데이터 복원
              data.p.forEach((p, idx) => {
                partyMembers[idx] = {
                  index: idx,
                  name: p.n,
                  order: p.o,
                  ritual: p.r
                };
                
                // 파티원 UI 업데이트
                const partyDiv = document.querySelector(`.party-member[data-index="${idx}"]`);
                if (partyDiv) {
                  // 이름 입력 필드 업데이트
                  const nameInput = partyDiv.querySelector(".party-name-input");
                  if (nameInput) {
                    nameInput.value = p.n || "";
                  }
                  
                  // 순서 선택 업데이트
                  const orderSelect = partyDiv.querySelector(".party-order");
                  if (orderSelect) {
                    orderSelect.value = p.o || "";
                  }
                  
                  // 의식 선택 업데이트
                  const ritualSelect = partyDiv.querySelector(".party-ritual");
                  if (ritualSelect) {
                    ritualSelect.value = p.r || "0";
                    
                    // 원더일 경우 의식 비활성화
                    if (p.n === "원더") {
                      ritualSelect.disabled = true;
                    } else {
                      ritualSelect.disabled = false;
                    }
                  }
                  
                  // 계시 설정 수정
                  const mainRevSelect = partyDiv.querySelector(".main-revelation");
                  const subRevSelect = partyDiv.querySelector(".sub-revelation");
                  
                  if (mainRevSelect) {
                    // 주 계시 옵션 초기화 및 설정
                    mainRevSelect.innerHTML = '<option value="">-</option>';
                    Object.keys(revelationData.main).forEach(rev => {
                      const opt = document.createElement("option");
                      opt.value = rev;
                      opt.textContent = rev;
                      mainRevSelect.appendChild(opt);
                    });
                    
                    // 주 계시 값 설정
                    mainRevSelect.value = p.mr || "";
                    
                    // 원더일 경우 계시 비활성화
                    if (p.n === "원더") {
                      mainRevSelect.disabled = true;
                      subRevSelect.disabled = true;
                      subRevSelect.value = "";
                    } else {
                      mainRevSelect.disabled = false;
                      
                      // 주 계시가 있는 경우 일월성진 옵션 설정
                      if (p.mr && revelationData.main[p.mr]) {
                        subRevSelect.disabled = false;
                        
                        // 일월성진 옵션 초기화 및 재설정
                        subRevSelect.innerHTML = '<option value="">-</option>';
                        revelationData.main[p.mr].forEach(subRev => {
                          const opt = document.createElement("option");
                          opt.value = subRev;
                          opt.textContent = subRev;
                          subRevSelect.appendChild(opt);
                        });
                        
                        // 저장된 일월성진 값 설정
                        if (p.sr) {
                          subRevSelect.value = p.sr;
                        }
                      } else {
                        subRevSelect.disabled = true;
                        subRevSelect.innerHTML = '<option value="">-</option>';
                      }
                    }
                  }
                }
              });
              
              // UI 기본 설정
              setupWonderConfig();
              setupPartySelection();
              
              // 계시 값 재설정 (setupPartySelection 이후에 실행)
              data.p.forEach((p, idx) => {
                const partyDiv = document.querySelector(`.party-member[data-index="${idx}"]`);
                if (partyDiv && p.mr) {
                  const mainRevSelect = partyDiv.querySelector(".main-revelation");
                  const subRevSelect = partyDiv.querySelector(".sub-revelation");
                  
                  if (mainRevSelect) {
                    mainRevSelect.value = p.mr;
                    
                    if (revelationData.main[p.mr]) {
                      subRevSelect.disabled = false;
                      subRevSelect.innerHTML = '<option value="">-</option>';
                      revelationData.main[p.mr].forEach(subRev => {
                        const opt = document.createElement("option");
                        opt.value = subRev;
                        opt.textContent = subRev;
                        subRevSelect.appendChild(opt);
                      });
                      
                      // 저장된 일월성진 값 설정
                      if (p.sr) {
                        subRevSelect.value = p.sr;
                      }
                    }
                  }
                }
              });
              
              updatePartyImages();
              renderTurns();
              
              // URL 파라미터 제거하여 이후 자동 업데이트 활성화
              window.history.replaceState({}, document.title, getBaseUrl());
              
            } catch (error) {
              console.error('Invalid file data:', error);
              alert('파일 형식이 올바르지 않습니다.');
            }
          };
          
          reader.readAsText(file);
        };
        
        input.click();
      }

      // 기본 URL을 가져오는 함수
      function getBaseUrl() {
        // 현재 페이지의 기본 URL을 반환 (쿼리 파라미터 제외)
        return window.location.href.split('?')[0];
      }

      // shareURL 함수 수정
      function handleShare() {
        // exportData와 동일한 데이터 구조 사용
        const url = shareURL();
        navigator.clipboard.writeText(url)
          .then(() => {
            alert('공유 URL이 클립보드에 복사되었습니다.');
          })
          .catch(err => {
            alert('URL 복사에 실패했습니다. 수동으로 복사해주세요.');
            console.error('Failed to copy: ', err);
          });

        // URL 파라미터 제거 시에도 동일하게 적용
        window.history.replaceState({}, document.title, getBaseUrl());
      }

      // UI 토글 함수 수정
      function toggleUI() {
        const container = document.querySelector('.container');
        const toggleBtn = document.querySelector('.toggle-ui-btn');
        
        container.classList.toggle('hide-ui');
        toggleBtn.classList.toggle('active');
        
        // 토글 상태 저장
        localStorage.setItem('uiHidden', container.classList.contains('hide-ui'));
      }

      // 페이지 로드 시 이전 상태 복원
      document.addEventListener('DOMContentLoaded', () => {
        const uiHidden = localStorage.getItem('uiHidden') === 'true';
        const toggleBtn = document.querySelector('.toggle-ui-btn');
        
        if (uiHidden) {
          document.querySelector('.container').classList.add('hide-ui');
          toggleBtn.classList.add('active');
        }
      });

    </script>
  </div>
</body>
</html>
